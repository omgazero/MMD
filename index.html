<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>mmdtest</title>
  <style>
    html {
      overflow: hidden;
    }
  </style>
</head>

<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>

  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/mmdparser.min.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/ammo.js"></script>

  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/TGALoader.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MMDLoader.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/effects/OutlineEffect.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/CCDIKSolver.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/MMDPhysics.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/MMDAnimationHelper.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js"></script>
  <script type="text/javascript">
    var frame, scene, camera, renderer, light, controls;
    var stats;
    var helper, ikHelper, physicsHelper;
    var modelFile = 'models/Rin/Rin.pmx';
    var vmdFiles = ['vmds/walk.vmd'];
    //var vmdFiles = ['models/DCD/DCD.vmd', 'models/DCD/555.vmd'];
    var vpdFiles = ['vpds/5.vpd'];
    var effect;
    var clock = new THREE.Clock();
    var mesh;
    init();
    animate();

    function init() {

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xffffff);
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      camera.position.z = 20;

      stats = new Stats();
      stats.showPanel(0);
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0px';
      stats.domElement.style.top = '0px';
      document.body.appendChild(stats.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);

      effect = new THREE.OutlineEffect(renderer);

      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(50, 100, 0);
      scene.add(light);

      ///ground
      let loaderT = new THREE.TextureLoader();
      loaderT.crossOrigin = '';
      let wood_ground = loaderT.load('images/wood_ground.jpg');
      wood_ground.repeat.set(5, 5);
      wood_ground.wrapS = THREE.RepeatWrapping;
      wood_ground.wrapT = THREE.RepeatWrapping;

      var ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshPhongMaterial({
        map: wood_ground
      }));
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -15.5;
      ground.material.userData.outlineParameters = {
        visible: false,
        keepAlive: false
      }
      scene.add(ground);

      ///model

      function onProgress(xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
      };

      function onError(xhr) {};

      var loader = new THREE.MMDLoader();
      console.log(modelFile);

      helper = new THREE.MMDAnimationHelper({
        afterglow: 2.0
      });

      loader.load(modelFile,
        function(mmd) {
          mesh = mmd;
          mesh.position.set(0, -15, 0);
          scene.add(mesh);

          helper.add(mesh, {
            physics: true
          });


          loader.loadVPD(vpdFiles[0], false, function(vpd) {
            helper.pose(mesh, vpd);
          }, onProgress, onError);


          /*loader.loadAnimation(vmdFiles, mesh, function(vmd){

            helper._setupMeshAnimation(mesh, vmd);
            //console.log(helper.meshes[0].skeleton.bones);
            console.log(mesh.morphTargetDictionary);
          },onProgress, onError);*/

          ikHelper = helper.objects.get(mesh).ikSolver.createHelper();
          ikHelper.visible = false;
          scene.add(ikHelper);

          physicsHelper = helper.objects.get(mesh).physics.createHelper();
          physicsHelper.visible = false;
          scene.add(physicsHelper);

          initGUI();
        },
        onProgress, onError);

      /////
      window.addEventListener('resize', onWindowResize, false);
    }

    function animate() {
      stats.begin();
      controls.update();

      stats.end();
      requestAnimationFrame(animate);
      render();
    }

    function render() {
      renderer.render(scene, camera);
      helper.update(clock.getDelta());
      effect.render(scene, camera);
    }

    function initGUI() {
      var gui = new dat.GUI();
      gui.domElement.id = 'gui';
      var dictionary = mesh.morphTargetDictionary;
      var morphs = gui.addFolder('Morphs');

      var controls = {};
      var keys = [];

      function initControls() {
        for (var key in dictionary) {
          controls[key] = 0.0;
        }

      }

      function initKeys() {
        for (var key in dictionary) {
          keys.push(key);
        }
      }

      function initMorphs() {
        for (var key in dictionary) {
          morphs.add(controls, key, 0.0, 1.0, 0.01).onChange(onChangeMorph);
        }
      }

      function onChangeMorph() {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = controls[key];
          mesh.morphTargetInfluences[i] = value;
        }
      }



      initControls();
      initKeys();
      initMorphs();
      onChangeMorph();
      morphs.open();


    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>

</body>

</html>
