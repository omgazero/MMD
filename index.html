<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>mmdtest</title>
  <style >
    html{
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/103/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>

<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/mmdparser.min.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/ammo.js"></script>

<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/TGALoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MMDLoader.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/effects/OutlineEffect.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/CCDIKSolver.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/MMDPhysics.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/MMDAnimationHelper.js"></script>
<script src="https://rawgit.com/mrdoob/three.js/src/loaders/LoaderUtils.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js"></script>
<script type="text/javascript">

var frame, scene, camera, renderer, light, controls;
var stats;
var helper, ikHelper, physicsHelper;
var modelFile = 'models/RIN/RIN.pmx';
var vmdFiles = ['vmds/walk.vmd'];
//var vmdFiles = ['models/DCD/DCD.vmd', 'models/DCD/555.vmd'];
var vpdFiles = ['vpds/5.vpd'];
var effect ;
var clock = new THREE.Clock();
var mesh, boneDictionary = [], gcontrol;
var mouseX = 0, mouseY = 0;
var headBoneName = '頭';
var eyesParam = {
				boneName: '左目',
				offset: new THREE.Vector3( -0.4, 0, 0 )
			};

init();
animate();

function init() {

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0xffffff);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
  camera.position.z = 20;

  stats = new Stats();
  stats.showPanel(0);
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.left = '0px';
  stats.domElement.style.top = '0px';
  document.body.appendChild( stats.domElement );
  controls = new THREE.OrbitControls(camera, renderer.domElement);

 effect = new THREE.OutlineEffect( renderer );

 light = new THREE.DirectionalLight(0xffffff);
 light.position.set(50, 100, 0);
 scene.add(light);

///ground
let loaderT = new THREE.TextureLoader();
loaderT.crossOrigin = '';
let wood_ground = loaderT.load('images/wood_ground.jpg');
wood_ground.repeat.set(5, 5);
wood_ground.wrapS = THREE.RepeatWrapping;
wood_ground.wrapT = THREE.RepeatWrapping;

var ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshPhongMaterial({map: wood_ground}));
ground.rotation.x = -Math.PI/2;
ground.position.y = -15.5;
ground.material.userData.outlineParameters ={
  visible: false,
  keepAlive: false
}
scene.add(ground);

///model

function onProgress( xhr ) {
	if ( xhr.lengthComputable ) {
		var percentComplete = xhr.loaded / xhr.total * 100;
		console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
	}
};
function onError( xhr ) {
};

var loader = new THREE.MMDLoader();
console.log(modelFile);

helper = new THREE.MMDAnimationHelper( {
					afterglow: 2.0
				} );

loader.load(modelFile,
	    function( mmd ){
	  mesh = mmd;
		mesh.position.set(0, -15, 0);
		scene.add(mesh );

		helper.add(mesh, {
			physics: true
		});


    loader.loadVPD(vpdFiles[0],false,function(vpd){
      helper.pose( mesh, vpd );
    },onProgress, onError);


    /*loader.loadAnimation(vmdFiles, mesh, function(vmd){

      helper._setupMeshAnimation(mesh, vmd);
      //console.log(helper.meshes[0].skeleton.bones);
      console.log(mesh.morphTargetDictionary);
    },onProgress, onError);*/

		ikHelper = helper.objects.get( mesh ).ikSolver.createHelper();
		ikHelper.visible = false;
		scene.add( ikHelper );

	 	physicsHelper = helper.objects.get( mesh ).physics.createHelper();
		physicsHelper.visible = false;
		scene.add( physicsHelper );

    gcontrol = new function(){
      this.HeadLookAtMouse = false;
    }
    initGUI();
    createDictionary();
    generateEyesSensor();
  //  letModelLookAtMouse();
	    },
	    onProgress, onError);

  /////
  document.addEventListener( 'mousemove', onMouseMove, false );
}

function animate() {
	stats.begin();
  controls.update();

  stats.end();
  requestAnimationFrame(animate);
  render();
}

function render() {
  renderer.render(scene, camera);
helper.update( clock.getDelta() );
effect.render( scene, camera );
}

function initGUI(){
  var gui = new dat.GUI();
  gui.domElement.id = 'gui';
  var dictionary = mesh.morphTargetDictionary;
  var headlook = gui.addFolder('Headlook');
  var morphs = gui.addFolder( 'Morphs' );

  var controls = {};
	var keys = [];

  function initControls() {
		for ( var key in dictionary ) {
			controls[ key ] = 0.0;
		}

	}
  function initKeys() {
		for ( var key in dictionary ) {
			keys.push( key );
		}
	}
  function initMorphs() {
  	for ( var key in dictionary ) {
  		morphs.add( controls, key, 0.0, 1.0, 0.01 ).onChange( onChangeMorph );
  	}
  }
  function onChangeMorph() {
		for ( var i = 0; i < keys.length; i ++ ) {
			var key = keys[ i ];
			var value = controls[ key ];
			mesh.morphTargetInfluences[ i ] = value;
		}
	}

  headlook.add(gcontrol,'HeadLookAtMouse');


  initControls();
  initKeys();
  initMorphs();
  onChangeMorph();
  morphs.open();


}

function createDictionary(){
  var bones = mesh.skeleton.bones;
	for ( var i = 0; i < bones.length; i++ ) {
		var b = bones[ i ];
		boneDictionary[ b.name ] = i;
	}
}
function generateEyesSensor ( ) {
	var p = eyesParam;
	var opacity = 0.2;
	var geometry = new THREE.BoxGeometry( 1, 1, 3 );
	var material = new THREE.MeshBasicMaterial( { color: 0x008888, transparent: true, opacity: opacity } );
	var cube = new THREE.Mesh( geometry, material );
	cube.name = 'eyes';
	cube.visible = false;
	if ( p.offset !== undefined ) {
		cube.position.add( p.offset );
	}
	mesh.skeleton.bones[ boneDictionary[ p.boneName ] ].add( cube );
	eyesSensor = cube;
}
function letModelLookAtMouse () {
				if ( gcontrol.HeadLookAtMouse === false ) {
					return;
				}
			//	var mesh = helper.meshes[ 0 ];
				// this parameter is heuristic.
				// you may need to adjust depending on model, camera, and etc.
				var pos = new THREE.Vector3( mouseX * 1920,
				                             mouseY * 1080,
				                             -camera.position.z * 6 );
				pos.unproject( camera );
				var bone = eyesSensor; //mesh.skeleton.bones[ 94 ];
				pos.sub( bone.getWorldPosition() );
				mesh.skeleton.bones[ boneDictionary[ headBoneName ] ].lookAt( pos );

			}
function onMouseMove ( event ) {
			// make mouseX/Y being between -1.0 and 1.0
			mouseX =  ( event.clientX / window.innerWidth ) * 2 - 1;
			mouseY = -( event.clientY / window.innerHeight ) * 2 + 1;
			letModelLookAtMouse();
      console.log(mouseX + "  " + mouseY);
		}
</script>

</body>
</html>
